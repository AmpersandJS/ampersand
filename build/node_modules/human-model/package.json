{
  "name": "human-model",
  "version": "2.6.0",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/henrikjoreteg/human-model.git"
  },
  "dependencies": {
    "backbone": "1.0.0",
    "underscore": "1.5.1"
  },
  "devDependencies": {
    "precommit-hook": "0.3.8",
    "uglify-js": "2.4.0"
  },
  "scripts": {
    "build": "node build.js"
  },
  "main": "./human-model.js",
  "browser": "./human-model.js",
  "readme": "# human-model\n\nHuman Models are meant to work as a drop-in replacement for Backbone models. In fact, it's extensively tested against the unit tests from Backbone (open test/index.html to run). \n\nHowever, Human Models are far more restrictive and structured. They force you to specify properties (at at minimum their types) for things you want it to store.\n\n\n## Module sytems/loaders/managers\n\nThanks to @svnlto, HumanModel uses UMD so it works as CommonJS (node + browserify), AMD, and as a standalone script tag.\n\n## Installing\n\nvia npm:\n\n```\nnpm install human-model\n```\n\nvia bower: \n\n```\nbower install human-model\n```\n\n## Why do this?\n\nBackbone models have a lot of flexibility in that you don't have to define what you're wanting to store ahead of time. \n\nThe only challenge with that is that for more complex applications is actually becomes quite difficult to remember what properties are available to you.\n\nUsing human models means they're much more self-documenting and help catch bugs. Someone new to the project can read the models and have a pretty good idea of how the app is put together.\n\nIt also uses's ES5's fancy `Object.defineProperty` to treat model attributes as if they were properties.\n\nThat means with Human Model you can set an attribute like this: `user.name = 'henrik'` and still get a `change:name` event fired. \n\nObviously, this restriction also means that this won't work in browsers that don't support that. You can check specific browser support here: http://kangax.github.io/es5-compat-table/\n\n\n## Key Differences from Backbone\n\nEverything Backbone does with Collections should Just Workâ„¢ with HumanModel as long as you specify a HumanModel constructor as a collection's `model` property.\n\n**important**: One key point to understand is that unlike backbone. You're actually passing an object definition that describes the Model, not just methods to attach to its prototype. For example, you'll notice we call `HumanModel.define()` instead of `Backbone.Model.extend()`. This is to make the distinction clear.\n\nBesides that and the obvious differences, any behavior that doesn't match Backbone should be considered a bug.\n\n\n### Explicit model definitions\n\nSchema definitions take an attribute called `props` to defined properties.\n\nProperty names can be defined two different ways, either an array with `[type, required, default]`,\nor an object: `{ type: 'string', required: true, default: '' , allowNull: false}`\n\ntypes can be: `string`, `number`, `boolean`, `array`, `object`, or `date`\nrequired: true, false (optional)\ndefault: any (optional)\nsetOnce: true, false (optional)\ntest: function (optional)\nallowNull: true, false (optional)\nvalues: `['some', 'valid', 'values']`(optional) \n\nNote that when defining with an array `type`, `required`, and `default`\nare the only property attributes you can set.\n\nIf `required` is true, the attribute will always have a value even if it is not explicitly set or is cleared.  If a default is given, that will be used.  If no default is given a default for its data type will be used (e.g. '' for string, {} for object)\n\nIf a `default` is given, the attribute will default to that value when the model is instantiated.\n\nIf `setOnce` is true, the attribute will throw an error if anything tries to set its value more than once.\n\nIf `values` is provided, you can only set that property to a value in the list. You can use this in combination with `type` to check both, or just use `values` and `default` by themselves. This is handy for `enum`-type stuff. For example:\n\n```js\nprops: {\n    alignment: {\n        values: ['top', 'middle', 'bottom'],\n        default: 'middle'\n    }\n}\n```\n\nIf given, `test` should be a function that expects the new value (and optionally the new type) of the attribute.  It should return an error message on failure, and false on success\n\n```js\nprops: {\n    firstName: ['string', true, 'Jim']\n    lastName: {\n        type: 'string', \n        required: false, \n        default: 'Bob' \n    }\n}\n```\n\n### A sample model with comments\n\n```js\nvar Person = HumanModel.define({\n    // every human model should have a type\n    type: 'member',\n    init: function () {\n        // main initialization function\n    },\n    // props are for properties that exist on the server\n    props: {\n        id: {\n            type: 'number',\n            setOnce: true\n        },\n        firstName: ['string', true],\n        lastName: ['string', true],\n        created: ['date'],\n        email: ['string', true],\n        username: ['string', true],\n        lastLogin: ['date'],\n        largePicUrl: ['string'],\n        department: {\n            type: 'number',\n            // you can optionally provide your own test function\n            test: function (val) {\n                if (val > 20) {\n                    return \"Invalid department\";\n                }\n            }\n        },\n        alignment: {\n            // you can also specify a list of valid values\n            values: ['top', 'middle', 'bottom'],\n            default: 'middle'\n        }\n    },\n    // derived properties and their dependencies. If any dependency changes\n    // that will also trigger a 'change' event on the derived property so\n    // we know to re-render the template\n    derived: {\n        // fullName is \n        fullName: {\n            // you can optionally define the properties this derived property\n            // depends on. That way if the underlying properties change you can\n            // listen for changes directly on the derived property.\n            deps: ['firstName', 'lastName'],\n            fn: function () {\n                return this.firstName + ' ' + this.lastName;\n            }\n        }\n    },\n    // Session properties are browser state for a model\n    // these trigger 'change' events when set, but are not\n    // included when serializing or saving to server.\n    session: {\n        selectedTasks: ['array', true, []],\n        lastPage: ['string', true, 'tasks'],\n        unread: ['boolean', true, false],\n        active: ['boolean', true, false]\n    },\n    // child collections that will be initted. They will\n    // be created at as a property of the same name as the\n    // key. The child collection will also be given a reference\n    // to its parent.\n    collections: {\n        // messages: Messages\n    },\n    otherMethods: function (cb) {\n        // of course you can tack on whatever other methods you want\n    }\n});\n```\n\n### Going hardcore \"strict\" definition\n\n[Strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode) in JS is pretty great and is fairly well supported in modern browsers.\n\nIf you want to be *really* hardcore about not letting you set properties that aren't defined, you can specify `seal: true` when defining your model.\n\n```js\n// enable strict mode\n\"use strict\";\n\nvar MySuperStrictModel = HumanModel.define({\n    // set this to true\n    seal: true,\n    // also throw errors for properties not defined\n    // when set via `set`.\n    extraProperties: 'reject',\n    // normal properties\n    props: {\n        name: 'string'\n    }\n});\n\n// create an instance of this model\nvar model = new MySuperStrictModel();\n\n// setting defined properties works like usual\nmodel.name = 'something';\n\n// BUT, setting a property that doesn't exist\n// will throw an error because the object is sealed.\nmodel.something = 'something else'; // KABOOM!\n\n```\n\n### Setting model attributes\n\n```js\n// backbone:\nuser.set('firstName', 'billy bob');\n\n// human:\nuser.firstName = 'billy bob';\n\n// p.s. you can still do it the other way in human (so you can still pass otions)\nuser.set('firstName', 'billy bob', {silent: true})\n```\n\n### Getting model attributes\n\n```js\n// backbone:\nuser.get('firstName');\n\n// human\nuser.firstName;\n```\n\n## The Registry\n\nHumanModel also inits a global registery for storing all initted models. It's designed to be used for looking up models based on their type, id and optional namespace.\n\nIt's purpose is finding/updating models when we get updates pushed to us from the server. This is very important for buildling realtime apps.\n\nTODO: needs more docs on the registry.\n\n## Tests\n\nAn extensive suite of tests can be run by opening `test/index.html` in a browser. In order to ensure compatibility with backbone to the extent possible I started with all the tests from Backbone 1.0.0 and modified them to use HumanModel.\n\n## Caveats \n\n- Since backbone does an `instanceof` check when adding initted models to a collection, HumanModel monkey patches the `_prepareModel` collection method to check against HumanModel instead.\n- Still needs better docs. Probably a full docs site.\n\n## Authors\n\nCreated by [@HenrikJoreteg](http://twitter.com/henrikjoreteg) with contributions from:\n\n- [@beausorensen](http://twitter.com/beausorensen)\n- [@LanceStout](https://twitter.com/lancestout)\n- [@philip_roberts](https://twitter.com/philip_roberts)\n- [@svenlito](https://twitter.com/svenlito)\n\n\n## Changelog\n\n - 2.6.0 - Cached, derived properties only fire change events now if new derived value is different from cache, instead of blindly firing change events if dependent properties changed.\n - 2.5.0 - UMD support by @swenlito\n - 2.4.0 - Added `toggle` method for boolean properties and properties with `values`\n - 2.3.0 - Added `values` to property definition\n - 2.2.0 - Added test parameter to property definitions\n - 2.1.0 - Added allowNull parameter to property definitions\n - 2.0.0 - Minor, but incompatible fix that remove `toServer` getter in lieu of adding `serialize` method that can be overridden.\n - 1.4.0 - Find/fix performance bottleneck. Significantly faster to instantiate larger numbers of models now.\n - 1.3.0 - Fix bug where session props were included in `.save()`\n - 1.2.0 - Make it possible to overwrite or extend data types.\n - 1.0.0 - Switching from `extend()` to `define()` pattern for building a model definition.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "description": "Human Models are meant to work as a drop-in replacement for Backbone models. In fact, it's extensively tested against the unit tests from Backbone (open test/index.html to run).",
  "bugs": {
    "url": "https://github.com/henrikjoreteg/human-model/issues"
  },
  "homepage": "https://github.com/henrikjoreteg/human-model",
  "_id": "human-model@2.6.0",
  "dist": {
    "shasum": "4c8913fa687968feb34c2cdb7aab7b93841d90b5"
  },
  "_from": "human-model@2.6.0",
  "_resolved": "http://registry.npmjs.org/human-model/-/human-model-2.6.0.tgz"
}
