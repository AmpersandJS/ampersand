{
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "name": "human-view",
  "description": "A smart base view for Backbone apps, to make it easy to bind collections and properties to the DOM.",
  "version": "1.5.0",
  "keywords": [
    "backbone",
    "view",
    "browser",
    "browserify"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/henrikjoreteg/human-view.git"
  },
  "main": "./human-view.js",
  "browser": "./human-view.js",
  "devDependencies": {
    "precommit-hook": "~0.3.8",
    "browserify": "~3.14.1",
    "uglify-js": "~2.4.8"
  },
  "scripts": {
    "validate": "jshint .",
    "build": "node build.js",
    "test": "open ./test/test.html"
  },
  "dependencies": {
    "backbone": "~1.0.0",
    "underscore": "~1.5.2"
  },
  "readme": "# human-view\n\nA set of common helpers and conventions for using as a base view for backbone applications.\n\nIt adds: \n\n1. Simple declarative property/template bindings without needing to include a template engine that does it for you. Which keeps your code with your code, you template as a simple function that returns an HTML string and your payload light.\n2. A pattern for easily including the view's base element into render. Rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.\n3. A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.\n\n\n## Install\n\n```\nnpm install human-view\n```\n\n## Usage\n\n### Basics\n\nNothing special is required, just use `HumanView` in the same way as you would Backbone.View:\n\n```js\nvar MyView = HumanView.extend({\n    initialize: function () { ... }, \n    render: function () { ... }\n});\n```\n\n### Declarative Bindings\n\n```js\nvar MyView = HumanView.extend({\n    // set a `template` property of your view. This can either be\n    // a function that returns an HTML string or just a string if \n    // no logic is required.\n    template: myTemplateFunction, \n    textBindings: {\n        // the model property: the css selector\n        name: 'li a' \n    },\n    render: function () {\n        // method for rendering the view's template and binding all\n        // the model properties as described by `textBindings` above.\n        // You can also bind other attributes, and if you're using\n        // human-model, you can bind derived properties too.\n        this.renderAndBind({what: 'some context object for the template'});\n    }\n});\n```\n\n#### Binding types:\n\n* `classBindings`: Maintains a class on the element according to the following rules:\n    1. **If the bound property is a boolean**: the name of the property will be used as the name of the class. The class will be on the element when true, and removed when the propety is false.\n    2. **If the property is a string**: the current value of the property will be used as the class name. When the property value changes the previous class will be removed and be replaced by the current value. No other classes on that element will be disturbed.\n* `textBindings`: Maintains the current value of the property as the text content of the element specified by the selector.\n* `htmlBindings`: Just like `textBindings` except html is not escaped.\n* `srcBindings`: Binds to the `src` attribute (useful for avatars, etc).\n* `hrefBindings`: Binds to the `href` attribute.\n* `inputBindings`: Binds to the `input` value.\n* `attributeBindings`: Lets you create other arbitrary attributes bindings. For example, this would bind the model's `id` attribute to the `data-id` attribute of the span element:\n\n    ```js\n    var View = HumanView.extend({\n        template: '<li><span></span></li>',\n        attributeBindings: {\n            // <model_property>: [ '<css-selector>', '<attribute-name>']\n            id: ['span', 'data-thing']\n        }\n    });\n    ```\n\n### handling subviews\n\nOften you want to render some other subview within a view. The trouble is that when you remove the parent view, you also want to remove all the subviews.\n\nHumanView has two convenience method for handling this that's also used by `renderCollection` to do cleanup.\n\nIt looks like this:\n\n```js\nvar HumanView = require('human-view');\n\n// This can be *anything* with a `remove` method\n// and an `el` property... such as another human-view\n// instance.\n// But you could very easily write other little custom views\n// that followed the same conventions. Such as custom dialogs, etc.\nvar SubView = require('./my-sub-view');\n\nmodule.exports = HumanView.extend({\n    render: function () {\n        // this takes a view instance and either an element, or element selector \n        // to draw the view into.\n        this.renderSubview(new Subview(), '.someElementSelector');\n\n        // There's an even lower level api that `renderSubview` usees\n        // that will do nothing other than call `remove` on it when\n        // the parent view is removed.\n        this.registerSubview(new Subview());\n    }\n})\n```\n\n**registerSubview also, stores a reference to the parent view on the subview as `.parent`**\n\n### rendering collections\n\nHumanView includes a `renderCollection` method that works as follows:\n\n```js\n// some view for individual items in the collection\nvar ItemView = HumanView.extend({ ... });\n\n// the main view\nvar MainView = HumanView.extend({\n    template: '<section class=\"page\"><ul class=\"itemContainer\"></ul></section>',\n    render: function (opts) {\n        // render our template as usual\n        this.renderAndBind();\n        \n        // call renderCollection with these arguments:\n        // 1. collection\n        // 2. which view to use for each item in the list\n        // 3. which element within this view to use as the container\n        // 4. options object (not required):\n        //      {\n        //          // function used to determine if model should be included\n        //          filter: function (model) {},\n        //          // boolean to specify reverse rendering order\n        //          reverse: false,\n        //          // view options object (just gets passed to item view's `initialize` method)\n        //          viewOptions: {}\n        //      }\n        this.renderCollection(this.collection, ItemView, this.$('.itemContainer')[0], opts);\n        return this;\n    }  \n})\n```\n\nThat will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc. You can optionally specify a filter function or choose to reverse the collection when rendering.\n\nAlso, when the parent view gets `.remove()`'ed any event handlers registered by the individual item views will be properly removed as well. \n\nEach item view will only be `.render()`'ed once (unless you change that within the item view itself).\n\n\n## Test coverage?\n\nWhy yes! So glad you asked :)  \n\nOpen `test/test.html` in a browser to run the QUnit tests.\n\n\n## Changelog\n\n1.5.0 - Adding bower.json, adding missing dev dependencies, other small bugfixes.\n1.4.1 - Removing elements without using jQuery's `.empty()` in renderCollection. (fixes: https://github.com/HenrikJoreteg/human-view/issues/13)\n1.4.0 - Adding `parent` reference to subviews registered via registerSubview\n\n## Like this?\n\nFollow [@HenrikJoreteg](http://twitter.com/henrikjoreteg) on twitter and check out my recently released book: [human javascript](http://humanjavascript.com) which includes a full explanation of this as well as a whole bunch of other stuff for building awesome single page apps. \n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/henrikjoreteg/human-view/issues"
  },
  "homepage": "https://github.com/henrikjoreteg/human-view",
  "_id": "human-view@1.5.0",
  "dist": {
    "shasum": "8955b8c9f09b27f5cbad3f0d5e588bbb39f575f0"
  },
  "_from": "human-view@1.5.0",
  "_resolved": "http://registry.npmjs.org/human-view/-/human-view-1.5.0.tgz"
}
